\chapter{Конструкторский раздел}

В данном разделе будут описаны особенности написания программ для
графических процессоров, а также алгоритмы и структуры данных,
выбранные для решения поставленной задачи.

\section{Особенности написания программ для графических процессоров}

Программы, написанные для выполнения на GPU называются шейдерными (шейдерами).
Конвеер графического процессора (см.~рисунок~\ref{img:pipeline}) -- 
последовательно запускаемые установленные пользователем 
шейдеры. Входными данными такого конвеера являются вершины и набор
настроек, вроде шейдерных переменных, текстур и др.
Конвеер в современных API (Vulkan, DirectX12 и др.) полностью настраивается 
программистом на этапе создания. В описание конвеера входит определение
шейдерных программ, и их переменных. Две основные шейдерные
программы -- это вершинная, и фрагементная (пиксельная). 
Особенностью работы GPU явяляется возможность параллельного запуска 
кода на множесвте потоков (более 100) и с встроенной обязательной работой 
в парадигме SIMD. Это означает, что запускаемый на одном из потоков код
на деле выполняет пакет вычислений одновременно. Такой подход дает 
отличную производительность в случае отсутствия условных переходов. Но 
появление условных переходов замедляет шейдерную программу в несколько раз.
По своему дизайну, трассировщики лучей включают в себя большое число условных
переходов (обработка случайных значений, проверка столкновений и т.д.) -- 
этот факт заставляет строить дизайн трассировщика для выполнения на графическом
процессоре иначе, чем для исполнения на центральном процессоре. В частности,
основная задача написания трассировщика лучей -- уменьшить количество 
условных переходов за счет предварительного вычисления части значений
~\cite{Vulkan}.

\begin{figure}[!ht]
  \centering
  \includesvg{inc/img/pipeline}
  \caption{Конвеер графического процессора}
  \label{img:pipeline}
\end{figure}

Из-за того, что современные графические процессоры написаны в первую очередь
для реализации алгоритма $z$-буфера, в большинстве из них
отсутствует аппаратная поддержка ускорения трассировки лучей. Для большей переносимости программы она должна быть написана без использования таких расширений -- алгоритм 
должен быть реализован с нуля в одной или нескольких шейдерных программах.

Следующая особенность программирования шейдеров -- модель доступа к памяти. 
Шейдеры не имеют прямого доступа к памяти центрального процессора. Они могут
получать доступ только к заранее определенным переменным (векторы, матрицы,
простые структуры, их массивы), либо к текстурам. Доступ к текстурам производится
быстрей, чем доступ к массивам, поэтому сложные данные обычно стараются 
закодировать в многомерную структуру. Для эффективной реализации
алгоритма трассировки лучей требуется составить алгоритм доступа к элементам
мирового пространства, переденным через текстуру. 

\section{Разработка алгоритмов}

\subsection{Алгоритм работы программы}

На рисунке~\ref{img:app_algo} приведена схема алгоритма работы программы.
$MAX\_BOUNCE\_COUNT$ -- это целочисленная константа, обозначающая максимальное число
отскоков одного луча. Под цветом понимается
трехмерный вектор в формате RGB в диапозоне $[0, 1)$. $rgb(0,0,0)$ -- функция черного цвета. 

\includeimage
    {app_algo}
    {f}
    {H}
    {0.70\textwidth}
    {Алгоритм работы программы}

\subsection{Алгоритм кэширования обратной репроекции}
Выполнение пиксельных шейдеров потребляет все большую часть вычислительного бюджета для приложений в 
реальном времени. Однако, значительная временная согласованность в видимых поверхностных областях, 
условиях освещения и расположении камеры позволяет повторно использовать вычислительно интенсивные 
расчеты освещения между кадрами, что позволяет достичь значительного повышения производительности 
при небольшом снижении визуального качества. 
Кэширование на основе обратной репроекции позволяет пиксельным шейдерам сохранять и повторно использовать 
расчеты, выполненные в видимых точках поверхности. 
Такой подход обеспечивает значительное повышение производительности для многих распространенных 
эффектов в реальном времени, включая предварительно вычисленные глобальные эффекты освещения, 
стереоскопическую отрисовку, движущийся размытый фон, глубину резкости и теневую картографию~\cite{ARTSwRPC}.

Временная обратная проекция - это процесс отображения ранее сгенерированного кадра на 
текущий кадр. Это позволяет повторно использовать информацию или, в случае трассировки 
лучей, накапливать сэмплы (и тем самым сходиться к решению уравнения отображения) даже при движении.

На рисунке~\ref{img:rrc} представлена блок-схема алгоритма Кэширования обратной
репроекции.

\includeimage
    {rrc}
    {f}
    {H}
    {0.40\textwidth}
    {Алгоритм Кэширования обратной репроекции}

\subsection{Алгоритм Русской Рулетки}

Для увелечения производительность вычисления трассировки лучей методом 
Монте-Карло может применяться т.н. алгоритм Русской рулетки.

Алгоритм заключается в увелечении вероятности того, что каждый пущенный луч
будет иметь значимый вклад в итоговую картинку. Русская рулетка отбрасывает
вычисление лучей, которые сложны для подсчета и при этом приносят малый 
радиометрический вклад в итоговую картинку~\cite{PBRT3e}.

На рисунке~\ref{img:rl} приведена блок-схема алгоритма Русской рулетки.
Здесь R -- минимальное число отскоков для инициализации алгоритма, 
C -- вероятностный параметр успеха работы алгоритма. Под $random[0,1)$ понимается
генерация случайного числа в диапозоне $[0,1)$.

\includeimage
    {rl}
    {f}
    {H}
    {0.70\textwidth}
    {Алгоритм Русской рулетки}

\section{Вывод}

В данном разделе были описаны особенности написания алгоритмов для выполнения
на графических процессорах, алгоритмы и структуры данных, выбранные 
и разработанные для решения поставленной задачи. 
